<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Treemap</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
    svg {
      border: 1px solid black;
    }
    .button-container {
      margin: 10px;
    }
  </style>
</head>
<body>

  <div class="button-container">
    <label><input type="radio" name="view" value="states" checked> States</label>
    <label><input type="radio" name="view" value="cities"> Cities</label>
  </div>

  <svg width="960" height="500"></svg>

  <script>
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    // Example with D3 v7 (or higher)
    var fader = function(color) { return d3.interpolateRgb(color, "#fff")(0.2); };

    // Use d3.schemeCategory10 or a custom array
    var color = d3.scaleOrdinal(d3.schemeCategory10.map(fader));

    var format = d3.format(",d");

    var treemap = d3.treemap()
        .tile(d3.treemapResquarify)
        .size([width, height])
        .round(true)
        .paddingInner(1);

    // Sample hierarchical JSON data
    var data = {
      "name": "USA",
      "children": [
        {
          "name": "California",
          "size": 50,
          "children": [
            { "name": "Los Angeles", "size": 20 },
            { "name": "San Francisco", "size": 15 },
            { "name": "San Diego", "size": 15 }
          ]
        },
        {
          "name": "Texas",
          "size": 40,
          "children": [
            { "name": "Houston", "size": 15 },
            { "name": "Dallas", "size": 10 },
            { "name": "Austin", "size": 15 }
          ]
        }
      ]
    };

    var root = d3.hierarchy(data)
        .eachBefore(function(d) { d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name; })
        .sum(sumBySize)
        .sort(function(a, b) { return b.height - a.height || b.value - a.value; });

    treemap(root);

    var cell = svg.selectAll("g")
      .data(root.leaves())
      .enter().append("g")
        .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

    cell.append("rect")
        .attr("id", function(d) { return d.data.id; })
        .attr("width", function(d) { return d.x1 - d.x0; })
        .attr("height", function(d) { return d.y1 - d.y0; })
        .attr("fill", function(d) { return color(d.parent.data.id); });

    cell.append("clipPath")
        .attr("id", function(d) { return "clip-" + d.data.id; })
      .append("use")
        .attr("xlink:href", function(d) { return "#" + d.data.id; });

    cell.append("text")
        .attr("clip-path", function(d) { return "url(#clip-" + d.data.id + ")"; })
      .selectAll("tspan")
        .data(function(d) { return d.data.name.split(/(?=[A-Z][^A-Z])/g); })
      .enter().append("tspan")
        .attr("x", 4)
        .attr("y", function(d, i) { return 13 + i * 10; })
        .text(function(d) { return d; });

    cell.append("title")
        .text(function(d) { return d.data.id + "\n" + format(d.value); });

    d3.selectAll("input")
        .data([sumBySize, sumByCount], function(d) { return d ? d.name : this.value; })
        .on("change", changed);

    var timeout = d3.timeout(function() {
      d3.select("input[value=\"sumByCount\"]")
          .property("checked", true)
          .dispatch("change");
    }, 2000);

    function changed(sum) {
      timeout.stop();

      treemap(root.sum(sum));

      cell.transition()
          .duration(750)
          .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; })
        .select("rect")
          .attr("width", function(d) { return d.x1 - d.x0; })
          .attr("height", function(d) { return d.y1 - d.y0; });
    }

    function sumByCount(d) {
      return d.children ? 0 : 1;
    }

    function sumBySize(d) {
      return d.size;
    }

    // Toggle between "states" and "cities"
    function toggleView() {
      var view = d3.select("input[name='view']:checked").node().value;

      // Re-calculate root based on selected view
      if (view === "cities") {
        root = d3.hierarchy(data)
            .eachBefore(function(d) { d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name; })
            .sum(sumBySize) // Use the sum for cities (based on size property)
            .sort(function(a, b) { return b.height - a.height || b.value - a.value; });
      } else {
        root = d3.hierarchy(data)
            .eachBefore(function(d) { d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name; })
            .sum(sumByCount) // Use the sum for states (just count the cities)
            .sort(function(a, b) { return b.height - a.height || b.value - a.value; });
      }

      treemap(root); // Re-apply the treemap layout to the updated root

      // Re-enter and update cells with the new hierarchy structure
      var cell = svg.selectAll("g")
        .data(root.leaves(), function(d) { return d.data.id; });

      // Remove old cells that are no longer needed
      cell.exit().remove();

      // Enter new cells and apply transitions
      var newCell = cell.enter().append("g")
        .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

      newCell.append("rect")
          .attr("id", function(d) { return d.data.id; })
          .attr("width", function(d) { return d.x1 - d.x0; })
          .attr("height", function(d) { return d.y1 - d.y0; })
          .attr("fill", function(d) { return color(d.parent.data.id); });

      newCell.append("clipPath")
          .attr("id", function(d) { return "clip-" + d.data.id; })
        .append("use")
          .attr("xlink:href", function(d) { return "#" + d.data.id; });

      newCell.append("text")
          .attr("clip-path", function(d) { return "url(#clip-" + d.data.id + ")"; })
        .selectAll("tspan")
          .data(function(d) { return d.data.name.split(/(?=[A-Z][^A-Z])/g); })
        .enter().append("tspan")
          .attr("x", 4)
          .attr("y", function(d, i) { return 13 + i * 10; })
          .text(function(d) { return d; });

      newCell.append("title")
          .text(function(d) { return d.data.id + "\n" + format(d.value); });

      // Apply transition for the layout changes
      newCell.transition()
          .duration(750)
          .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; })
        .select("rect")
          .attr("width", function(d) { return d.x1 - d.x0; })
          .attr("height", function(d) { return d.y1 - d.y0; });
    }

    // Listen for view toggle changes
    d3.selectAll("input[name='view']").on("change", toggleView);

    // Initial view
    toggleView();
  </script>

</body>
</html>
