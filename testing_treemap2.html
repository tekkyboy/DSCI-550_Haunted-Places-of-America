<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>USA Treemap</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .node rect {
      stroke: #fff;
    }
    .label {
      pointer-events: none;
      font-size: 12px;
      fill: white;
      text-shadow: 1px 1px 2px black;
    }
    .state-label {
      font-size: 16px;
      font-weight: bold;
      fill: black;
    }
  </style>
</head>
<body>

<svg width="11000" height="11000"></svg>

<script>
d3.json("https://raw.githubusercontent.com/tekkyboy/DSCI-550_Haunted-Places-of-America/main/DSCI-550_Visualizations_JSON/treemap_data_sorted.json")
  .then(function(data) {
    const width = 11000, height = 11000;
    const svg = d3.select("svg");

    const numberOfStates = data.children.length;

    const color = d3.scaleSequential()
    .domain([0, numberOfStates])
    .interpolator(d3.interpolateRainbow);
    
    const root = d3.hierarchy(data)
    .eachAfter(d => {
    if (!d.children) {
      d.data._originalValue = d.data.value || 0;
    } else {
      d.data._totalValue = d.children.reduce((sum, child) => sum + (child.data._originalValue || 0), 0);
    }
    })
    .sort((a, b) => {
      if (a.depth !== b.depth) return a.depth - b.depth; // always keep parents before children
      if (a.depth === 1) {
      // At state level (depth 1), sort by _totalValue descending
      return (b.data._totalValue || 0) - (a.data._totalValue || 0);
      }
      return 0; // No specific order for cities
    })
    .count();  // still needed to set up the layout



  d3.treemap()
    .size([width, height])
    .paddingInner(0.5)    // â†“ smaller gap between cities
    .paddingOuter(1)      // slight gap around entire block
    .paddingTop(d => d.depth === 1 ? 16 : 0) // space for state labels only
    (root);


    const node = svg.selectAll("g")
      .data(root.descendants())
      .join("g")
      .attr("transform", d => `translate(${d.x0},${d.y0})`);

  node.append("rect")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", d => {
      if (d.depth === 1) {
        return color(d.parent.children.indexOf(d));
      }
      if (d.parent) {
        return color(d.parent.parent.children.indexOf(d.parent));
      }
      return "#ccc";
    });

  // City Labels (uniform size, but show actual value)
  node.filter(d => !d.children).append("text")
    .attr("class", "label")
    .attr("x", 4)
    .attr("y", 14)
    .attr("font-size", d => {
    const boxWidth = d.x1 - d.x0;
    const boxHeight = d.y1 - d.y0;
    const nameLength = d.data.name.length + 5; // name + value extra characters
    // Font size shrinks if box is too narrow
    return Math.min((boxWidth / nameLength) * 1.5, boxHeight * 0.6, 12); // 12px max
    })
    .text(d => `${d.data.name} (${d.data._originalValue})`);

    
  // State Labels with Total Value
  node.filter(d => d.depth === 1).append("text")
    .attr("class", "state-label")
    .attr("x", 4)
    .attr("y", 16)
    .text(d => `${d.data.name} (${d.data._totalValue})`);

  });
</script>
</body>
</html>
